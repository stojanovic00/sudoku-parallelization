\section{Секвенцијална имплементација}\label{sec:sequential}
у овом поглављу биће описана секвенцијална имплементација, на којој ће се темељити и све наредне паралелне имплементације.

\subsection{Структуре података}

На почетку потребно је моделовати појединачну ћелију судоку матрице, као и читаву матрицу \ref{code:seq_structures}. Ћелија је прeдстављена као структура која од поља садржи коначну вредност (\textit{value}), која може варирати од 1 до \textit{n}, као и поље \textit{possibilities} којe ће се , ради уштеде меморијског простора, третирати као бинарни низ могућих вредности ћелије, где јединица на одређеном биту означава могућност појаве броја. На пример у случају 9х9 матрице број 0b1\_1010\_0010 значио би да су могуће вредности те ћелије бројеви 2, 6, 8 и 9. Читава матрица моделована је као дводимензионални низ ћелија. Уз ове структуре података имплементиране су и тривијалне помоћне методе за учитавање и писање матрице у \textit{csv} фајл, испис матрице на екран, копирање, као и проверу да ли је судоку решен тако што се проверава да ли све ћелије имају вредност у опсегу од 1 до \textit{n}, као и да им је низ могућих бројева једнак нули (0b0\_0000\_0000).

\begin{listing}[H]
\inputminted{c}{kodovi/seq_structures.c}
\caption{Неопходне структуре података}
\label{code:seq_structures}
\end{listing}

\subsection{Пропагирање ограничења}\label{constraint_prop}

Срж имплементације налази се у  \textit{solve} функцији, која се позива након учитавања нерешене судоку матрице. Као што је претходно поменуто, она се есенцијално састоји из два алгоритма, алгоритма за пропагирање   ограничења и алгоритма за претрагу простора могућих решења.\\

Пропагирање решења почиње применом претходно наведена 2 правила (\ref{rules}) над свим \textit{singleton}-има, а затим се у бесконачној петљи наизменично врше две акције. У првој се проналазе новонастали \textit{singleton}-и, додељује им се једини могући број и затим пропагирају ограничења која су произведена додавањем броја у ћелију. У другој акцији примењује се друго правило, где се за одређену ћелију проверава да ли постоји број који је избачен из низа потенцијалних бројева у свакоj од ћелија \textit{unit}-а посматране ћелије и ако је то случај ћелији се додељује тај број и пропагирају новонастала ограничења. Петља се прекида у тренутку када се нађе коначно решење (ово се може десити у лакшим загонеткама) или док се не примети да не постоји разлика у насталим судоку матрицама у претходне две итерације, што би значило да су ограничења максимално пропагирана и да је дошло време за претрагу простора могућих решења. Може се такође догодити ситуација када се пропагирањем ограничења дође у контрадикторно стање, у ком случају \textit{solve} функција враћа \textit{NULL} као решење. Овакво понашање битно је за наредни алгоритам.

\begin{listing}[H]
\inputminted{c}{kodovi/rules_propagation.c}
\caption{Пропагирање ограничења за ћелију}
\label{code:rules_propagation}
\end{listing}

\begin{listing}[H]
\inputminted{c}{kodovi/common_forbidden.c}
\caption{Имплементација примене другог правила}
\label{code:common_forbidden}
\end{listing}

Да се приметити да одлука за бинарну представу могућих бројева ћелије, поред уштеде меморијског простора, омогућава и ефикасније баратање низовима у овим случајевима коришћења где су итерације кроз низ у потпуности замењене бинарним операцијама О(1) комплeксности.

\subsection{Претрага простора могућих решења}

Након што се максимално испропагирају ограничења, прелази се на претрагу простора могућих решења \ref{code:seq_search}. Да нагађање не би било потпуно насумично, проналази се "оптимални кандидат" за нагађање, то јест ћелија која има најмањи број потенцијалних бројева. На овај начин минимизује се број гранања, а тиме и укупно време претраге у најгорем случају. Затим се пролази кроз сваки могући број посматране ћелије, додељује се ћелији и са тако измењеном судоку матрицом рекурзивно се позива \textit{solve} функција. Као што је поменуто у \ref{constraint_prop}, рекурзивна претрага наставља се све док се не дође до коначног решења или у случају доласка у контрадикторно стање матрице, где се онда алгоритам враћа до последњег валидног стања и даље покушава са другим бројем.

\begin{listing}[H]
\inputminted{c}{kodovi/seq_search.c}
\caption{Алгоритам претраге  простора могућих решења}
\label{code:seq_search}
\end{listing}