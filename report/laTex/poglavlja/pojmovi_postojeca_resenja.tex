\section{Основни појмови и постојећа решења}

Да би разумевање рада алгоритама за решавање ове загонекте било лакше, потребно је увести неколико основних појмова.\\

Појединачно поље у које се може сместити број назива се \textbf{ћелија}.\\

Ћелија која у датом тренутку решавања има само један број који је могуће уписати, без да се наруше ограничења, назива се \textbf{\textit{singleton}}.\\

Подматрица димензија \(\sqrt{n} \times \sqrt{n}\) која у себи мора садржати свих \textit{n} бројева назива се \textbf{\textit{box}}.\\

\textbf{\textit{Peer}}-ом се назива свака ћелија којa се налази у истој врсти, колони или \textit{box}-у (било која од ове три групације генерално се може називати \textbf{\textit{unit}}) у односу на посматрану ћелију.\\

Оно што је заједничко за све постојеће радове \cite{sudokuMulti,sudokuReport,sudokuMPI} као и ауторову имплементацију је то да се решавање загонетке заснива на два алгоритма, пропагацији ограничења и претрагом простора могућих решења.

\subsection{Пропагирање ограничења}
У уводном поглављу споменуто је основно ограничење загонетке које захтева да се унутар сваког \textit{unit}-а морају наћи сви бројеви и то тачно једном. Приликом решавања загонетке, ово ограничење се може рашчланити на два правила:
\begin{itemize}\label{rules}
    \item Ако се у некој од ћелија \textit{unit}-а посматране ћелије већ налази неки број, тај број се уклања из листе могућих бројева посматране  ћелије.
    \item Ако све ћелије \textit{unit}-a посматране ћелије сем ње имају одређен број избачен из њихове листе могућих бројева, тај број припада посматраној ћелији.
\end{itemize}

Узевши ова правила у обзир први корак решавања алгоритма била би њихова максимална примена широм целе матрице, све док се не дође до ситуације када још увек постоје празне ћелије, али немогуће их је попунити само на основу задатих правила.

\subsection{Претрага простора могућих решења}

Овај алгоритам полази од максимално попуњене матрице на основу правила из 2.1, затим користећи се скупом могућих бројева неке ћелије нагађа који би број могао стајати у њој и након тога наставља са пропагацијом ограничења, све док поново не дође до ситуације када мора да нагађа, ситуације када долази до крајњег решења или до контрадикторне ситуације. У случају проналаска решења алгоритам се овде завршава, а у случају контрадикторне ситуације алгоритам се враћа до последњег валидног стања матрице и покушава са новим бројем. Може се приметити да је овај алгоритам класичан пример \textit{back tracking} алгоритма \cite{backtrack}.\\